# 23/5/17
## 11.说说前端中的事件流
    HTML 中与 javascript 交互是通过事件驱动来实现的，例如鼠标点击事件 onclick、页
    面的滚动事件 onscroll 等等，可以向文档或者文档中的元素添加事件侦听器来预订事
    件。想要知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概
    念。
    什么是事件流：事件流描述的是从页面中接收事件的顺序,DOM2 级事件流包括下面几个
    阶段。
    事件捕获阶段
    处于目标阶段
    事件冒泡阶段
    addEventListener：addEventListener 是 DOM2 级事件新增的指定事件处理程序的操
    作，这个方法接收 3 个参数：要处理的事件名、作为事件处理程序的函数和一个布尔
    值。最后这个布尔值参数如果是 true，表示在捕获阶段调用事件处理程序；如果是
    false，表示在冒泡阶段调用事件处理程序。
    IE 只支持事件冒泡。
## 12.JS 拖拽功能的实现
    首先是三个事件，分别是 mousedown，mousemove，mouseup
    当鼠标点击按下的时候，需要一个 tag 标识此时已经按下，可以执行 mousemove 里面
    的具体方法。
    clientX，clientY 标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用
    offsetX 和 offsetY 来表示元素的元素的初始坐标，移动的举例应该是：
    鼠标移动时候的坐标-鼠标按下去时候的坐标。
    也就是说定位信息为：
    鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的 offetLeft.
    还有一点也是原理性的东西，也就是拖拽的同时是绝对定位，我们改变的是绝对定位
    条件下的 left
    以及 top 等等值。
    补充：也可以通过 html5 的拖放（Drag 和 drop）来实现
## 13.Ajax 解决浏览器缓存问题
    在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader("If-Modified-
    Since","0")。
    在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader("Cache-Control","no-
    cache")。
    在 URL 后面加上一个随机数： "fresh=" + Math.random()。
    在 URL 后面加上时间搓："nowtime=" + new Date().getTime()。
    如果是使用 jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所
    有 ajax 都会执行这条语句就是不需要保存缓存记录。
## 14.eval 是做什么的
    它的功能是将对应的字符串解析成 JS 并执行，应该避免使用 JS，因为非常消耗性能
    （2 次，一次解析成 JS，一次执行）
## 15.如何理解前端模块化
    前端模块化就是复杂的文件编程一个一个独立的模块，比如 JS 文件等等，分成独立的
    模块有利于重用（复用性）和维护（版本迭代），这样会引来模块之间相互依赖的问
    题，所以有了 commonJS 规范，AMD，CMD 规范等等，以及用于 JS 打包（编译等处理）
    的工具 webpack
## 16.事件代理在捕获阶段的实际应用
    可以在父元素层面阻止事件向子元素传播，也可代替子元素执行某些操作。
## 17.跨域的原理
    跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏
    览器对 JavaScript 实施的安全限制，那么只要协议、域名、端口有任何一个不同，都
    被当作是不同的域。跨域原理，即是通过各种方式，避开浏览器的安全限制。
## 18.什么是按需加载
    当用户触发了动作时才加载对应的功能。触发的动作，是要看具体的业务场景而言，
    包括但不限于以下几个情况：鼠标点击、输入文字、拉动滚动条，鼠标移动、窗口大
    小更改等。加载的文件，可以是 JS、图片、CSS、HTML 等。
## 19.webpack 用来干什么的
    webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当
    webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其
    中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。
## 20.ant-design 优点和缺点
    优点：组件非常全面，样式效果也都比较不错。
    缺点：框架自定义程度低，默认 UI 风格修改困难。
# 23/5/16
## 1.闭包是什么，闭包的作用是什么，对页面有什么影响?
    答：一个函数作为另一个函数的返回值，返回的这个函数可以调用父函数内部的其他变量
    作用：防止全局污染，保存外部活动变量
    影响：如果过多使用闭包，容易导致内存泄露
## 2.原型链
    任何一个类（函数）都有原型对象，原型对象至少有两个属性（constructor,proto）。constructor指向函数本身，proto指向父类原型对象。
    函数上有一个prototype属性，指向原型对象，通过它可以访问原型对象
    函数的实列可以直接访问原型对象(因为实列上有proto指向构造函数的原型对象)
## 3.浏览器缓存机制
    缓存分为两种：强缓存和协商缓存，根据响应的 header 内容来决定。
    强缓存相关字段有 expires，cache-control。如果 cache-control 与 expires 同时存
    在的话，cache-control 的优先级高于 expires。
    协商缓存相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match
## 4.transition 和 和 n animation 的区别
    Animation 和 transition 大部分属性是相同的，他们都是随时间改变元素的属性值，
    他们的主要区别是 transition 需要触发一个事件才能改变属性，而 animation 不需要
    触发任何事件的情况下才会随时间改变属性值，并且 transition 为 2 帧，从
    from .... to，而 animation 可以一帧一帧的
## 5.get 和 和 t post 请求在缓存方面的区别
    get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以
    使用缓存。
    post 不同，post 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使
    用缓存。因此 get 请求适合于请求缓存。
## 6.call() 、apply()、bind()区别
    ● call() 和 apply() 方法直接调用原函数，并传递参数列表（或类数组对象）作为参数，它们能够立即改变函数的执行上下文。
    ● bind() 方法会创建一个新函数并返回它，而不是像 call() 和 apply() 方法一样立即调用原函数。新函数将原来的函数与指定的 this 值和参数绑定在一起，在随后的调用中，它们无法再次更改。
    另外，call() 和 apply() 通常用于临时更改函数的执行上下文，而bind() 则经常用于永久地将函数绑定到特定的上下文中，例如在事件处理程序或回调函数中。
     最后，需要注意的是这三个方法所表示的行为，都属于 JavaScript 的高阶函数特性，能够让我们更灵活的使用 JavaScript 函数进行编程。
## 7.原型链的概念及其作用
    在 JavaScript 中，每个对象都有一个指向它的原型对象，这些对象被链接在一起形成了原型链。当访问一个对象的属性或方法时，JavaScript 会沿着原型链向上查找，直到找到匹配的属性或方法为止。这种查找方式使得对象的属性和方法可以被共享和继承。
## 8.Local Storage特点
    Local Storage 存储的数据量是有限的，通常为 5MB 到 10MB 不等，如果超过了这个限制则会抛出异常。此外，Local Storage 存储的数据会一直存在于用户的浏览器中，即使关闭了浏览器或电脑，数据也不会被清除
## 9.具体有哪些请求头是跟缓存相关的
    缓存分为两种：强缓存和协商缓存，根据响应的 header 内容来决定。
    强缓存相关字段有 expires，cache-control。如果 cache-control 与 expires 同时存
    在的话，cache-control 的优先级高于 expires。
## 10.cookie 和 和 n session 的区别
    1. cookie 数据存放在客户的浏览器上，session 数据放在服务器上。
    2. cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺
    骗
    考虑到安全应当使用 session。
    3. session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务
    器的性能
    考虑到减轻服务器性能方面，应当使用 COOKIE。
    4. 单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存
    20 个 cookie。