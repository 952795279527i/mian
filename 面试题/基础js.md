# 23/5/23
## 61.v-if 和 v-show 有什么区别？
    v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建，
    操作的实际上是 dom 元素的创建或销毁。
    v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换，
    它操作的是display:none/block属性。
    一般来说， v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较  好；
    如果在运行时条件很少改变，则使用 v-if 较好。
## 62. v-for 循环为什么一定要绑定 key ?
    页面上的标签都对应具体的虚拟 dom 对象(虚拟 dom 就是 js 对象), 循环中 ,如果没有唯一 key , 页面上删除 一条标 
    签, 由于并不知道删除的是那一条! 所以要把全部虚拟 dom 重新渲染, 如果知道 key 为 x 标签被删除 掉, 只需要把渲染的 dom 为 x 的标签去掉即可!
## 63.知道 lodash 吗？它有哪些常见的 API ？
    Lodash 是一个一致性、模块化、高性能的 JavaScript 实用工具库。
    _.cloneDeep 深度拷贝
    _.reject 根据条件去除某个元素。
    _.drop(array, [n=1] ) 作用：将 array 中的前 n 个元素去掉，然后返回剩余的部分.
## 64.什么是同源策略？
    所谓同源策略是浏览器的一种安全机制，来限制不同源的网站不能通信。同源就是域名、协议、端口一 致。
## 65.$nextTick
    nextTick()，是将回调函数延迟在下一次dom更新数据后调用，简单的理解是：当数据更新了，在dom中渲染后，自动执行该函数，
    在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中
    在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。
## 66.伪数组（类数组）
    一个拥有length属性和若干索引属性的对象可以被成为类数组对象，类数组对象和数组类似，但不能调用数组的方法
    常见的类数组对象：arguments和DOM方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数
## 67.axios
    Axios 是一种基于Promise封装的HTTP客户端
    浏览器端发起XMLHttpRequests请求
    node端发起http请求
    支持Promise API
    监听请求和返回
    对请求和返回进行转化
    取消请求
    自动转换json数据
    客户端支持抵御XSRF攻击
## 68..MVVM
    MVVM（Model-View-ViewModel）模式是一种基于前端开发的架构模式，其核心是提供对 View 和 Model 的双向数据绑定，即当 View 或 Model 其中任意一个发生变化时，都会通过 ViewModel 引起另外一个的改变。
## 69.MVVM的优点
    1.双向绑定。数据层和视图层中任何一层发生变化，都会通过ViewModel使另一层变化，时刻保持数据和视图的一致性；
    2.通过数据驱动视图更新，不再手动操作DOM元素，提高性能；
## 70.MVVM的缺点
    1.由于双向绑定的技术，产生bug后无法确定问题出现在数据层还是视图层；
    2.数据层过大会占用更多的内存资源，影响性能；
# 23/5/22
## 51.img的alt和title的异同？
    alt 是图片加载失败时，显示在网页上的替代文字；title 是鼠标放上面时显示的文字,title是对图片的描述与进一步说明;
    这些都是表面上的区别，alt是img必要的属性，而title不是。
    对于网站seo优化来说，title与alt还有最重要的一点： 搜索引擎对图片意思的判断，主要靠alt属性。所以在图片alt 属性中以简要文字说明，同时包含关键词，也是页面优化的一部分。条件允许的话，可以在   title属性里，进一步对图 片说明。
## 52.map和foreach区别是什么？
    相同点：
    1、都是遍历数组
    2、匿名函数中的this都是指向window
    
    区别：
    map方法：返回一个新的数组，不改变原数组
    
    array.map((item, index, array)=>{
        //do something
    })
    
    forEach方法：没有返回值，可以改变原数组
    
    array.forEach((item, index, array)=>{
        //do something
    })
## 53.webpack 和 gulp 区别（模块化与流的区别）
    gulp 强调的是前端开发的工作流程，我们可以通过配置一系列的 task，定义 task 处
    理的事务（例如文件压缩合并、雪碧图、启动 server、版本控制等），然后定义执行
    顺序，来让 gulp 执行这些 task，从而构建项目的整个前端开发流程。
    webpack 是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图
    片、js 文件、css 文件等）都看成模块，通过 loader（加载器）和 plugins（插件）
    对资源进行处理，打包成符合生产环境部署的前端资源。
## 54.什么是虚拟 DOM？
    虚拟 dom 是相对于浏览器所渲染出来的真实 dom 的，在 react，vue 等技术出现之
    前，我们要改变页面展示的内容只能通过遍历查询 dom 树的方式找到需要修改的 dom 
    然后修改样式行为或者结构，来达到更新 ui 的目的。
    这种方式相当消耗计算资源，因为每次查询 dom 几乎都需要遍历整颗 dom 树，如果
    建立一个与 dom 树对应的虚拟 dom 对象（ js 对象），以对象嵌套的方式来表示
    dom 树，那么每次 dom 的更改就变成了 js 对象的属性的更改，这样一来就能查找
    js 对象的属性变化要比查询 dom 树的性能开销小。
## 55.状态码 304 和 200
    状态码 200：请求已成功，请求所希望的响应头或数据体将随此响应返回。即返回的数
    据为全量的数据，如果文件不通过 GZIP 压缩的话，文件是多大，则要有多大传输量。
    状态码 304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的
    内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状
    态码。即客户端和服务器端只需要传输很少的数据量来做文件的校验，如果文件没有
    修改过，则不需要返回全量的数据。
## 56.cache-control 的值有哪些
    cache-control 是一个通用消息头字段被用于 HTTP 请求和响应中，通过指定指令来实
    现缓存机制，这个缓存指令是单向的，常见的 取值有 private 、no-cache、max-age、
    must-revalidate 等，默认为 private。
## 57.浏览器在生成页面的时候，会生成哪两颗树？
    构造两棵树，DOM 树和 CSSOM 规则树，
    当浏览器接收到服务器相应来的 HTML 文档后，会遍历文档节点，生成 DOM 树，
    CSSOM 规则树由浏览器解析 CSS 文件生成。
## 58.怎么看网站的性能如何
    检测页面加载时间一般有两种方式，一种是被动去测：就是在被检测的页面置入脚本
    或探针，当用户访问网页时，探针自动采集数据并传回数据库进行分析，另一种主动
    监测的方式，即主动的搭建分布式受控环境，模拟用户发起页面访问请求，主动采集
    性能数据并分析，在检测的精准度上，专业的第三方工具效果更佳，比如说性能极
    客。
## 59.双边距重叠问题（外边距折叠）
    多个相邻（兄弟或者父子关系）普通流的块元素垂直方向 margin 会重叠
    折叠的结果为：
    两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。
    两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。
    两个外边距一正一负时，折叠结果是两者的相加的和。
## 60.使元素消失的方法有哪些？
    1. opacity ：0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑
    定一些事件，如 click 事件，那么点击该区域，也能触发点击事件的
    2. visibility ：hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该
    元素已经绑定的事件
    3. display：none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把
    该元素删除掉。
# 23/5/21
## 41.Flash、Ajax 各自的优缺点，在使用中如何取舍？
    1、Flash ajax 对比
    Flash 适合处理多媒体、矢量图形、访问机器；对 CSS、处理文本上不足，不容易被搜索。
    Ajax 对 CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
    共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作 DOM
## 42.针对 jQuery 的优化方法？
    优先使用 ID 选择器
    在 class 前使用 tag(标签名)
    给选择器一个上下文
    慎用 .live()方法（应该说尽量不要使用）
    使用 data()方法存储临时变量
## 43.angular 中$rootScope 和 scope 有什么区别？
    scope 是 html 和单个 controller 之间的桥梁，数据绑定就靠他了。rootscope 是各个 
    controller 中 scope 的
    桥梁。用 rootscope 定义的值，可以在各个 controller 中使用。
## 44.Vue 实现单页
    ① 构建项目 首先创建各个组件
    ② 配置路由 首先在我们的项目中安装 vue-router 引入各个组件并配置路由
    ③ 利用 v-link 实现路由链接
## 45.混合 app 的优点
    混合应用大家都知道是原生应用和 Web 应用的结合体，采用了原生应用的一部分、Web 应用的一部 
    分，所以
    必须在部分在设备上运行、部分在 Web 上运行。
    不过混合应用中比例很自由，比如 Web 占 90%，原生占 10%；或者各占 50%。
    优点：
    兼容多平台；
    顺利访问手机的多种功能；
    App Store 中可下载（Wen 应用套用原生应用的外壳）；
    可线下使用。
    缺点：
    用户体验不如本地应用；
    性能稍慢（需要连接网络）；
    技术还不是很成熟。
## 46.如何避免回调地狱？
    可以这么解决：1、模块化：将回调函数分割为独立的函数 2、使用 Promises
    3、使用 yield 来计算生成器或 Promise
## 47.为什么要用 node？
    总结起来 node 有以下几个特点:简单强大，轻量可扩展．简单体现在 node 使用的是javascript,json 来进行编
    码，人人都会；强大体现在非阻塞 IO,可以适应分块传输数据，较慢的网络环境，尤其擅长高并发访问；轻量
    体现在 node 本身既是代码，又是服务器，前后端使用统一语言;可扩展体现在可以轻松应对多实例，多服务器
    架构，同时有海量的第三方应用组件．
## 48.Node.js 的适用场景？
    1)、实时应用：如在线聊天，实时通知推送等等（如 socket.io）
    2)、分布式应用：通过高效的并行 I/O 使用已有的数据
    3)、工具类应用：海量的工具，小到前端压缩部署（如 grunt ），大到桌面图形界面应用程序
    4)、游戏类应用：游戏领域对实时和并发有很高的要求（如网易的 pomelo 框架）
    5)、利用稳定接口提升 Web 渲染能力
    6)、前后端编程语言环境统一：前端开发人员可以非常快速地切入到服务器端的开发（如著名的纯 
    Javascriptc
    全栈式 MEAN 架构）
## 49.跨域（ jsonp ，ajax）
    JSONP：ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中
    的链接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数
    据，而是返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。
## 50.watch 和计算属性有什么区别？
    通俗来讲，既能用 computed 实现又可以用 watch 监听来实现的功能，推荐用
    computed，重点在于 computed 的缓存功能
    computed 计算属性是用来声明式的描述一个值依赖了其它的值，当所依赖的值或者变
    量改变时，计算属性也会跟着改变；
    watch 监听的是已经在 data 中定义的变量，当该变量变化时，会触发 watch 中的方
    法。
# 23/5/19
## 31.jq 和 zepto 区别是什么
    1,width()和 height()的区别：Zepto 由盒模型(box-sizing)决定，用.width()返回赋值的 
    width，用.css('width')返
    回加 border 等的结果；jQuery 会忽略盒模型，始终返回内容区域的宽/高(不包含     
    padding、border)。
    2,offset()的区别：Zepto 返回{top,left,width,height}；jQuery 返回{width,height}。
    3,Zepto 无法获取隐藏元素宽高，jQuery 可以。
    4,Zepto 中没有为原型定义 extend 方法而 jQuery 有。
## 32.jquery 对象和 dom 对象是怎样转换的？
    jquery转DOM对象:jQuery 对象是一个数组对象，可以通过[index]的得到相应的DOM对象还可以通过get[index]
    去得到相应的 DOM 对象。DOM 对象转 jQuery 对象:$(DOM 对象)
## 33.ajax 出现错误怎么调试？
    JQuery 使我们在开发 Ajax 应用程序的时候提高了效率，减少了许多兼容性问题，我们在 Ajax 项目中，遇到
    ajax 异步获取数据出错怎么办，我们可以通过捕捉 error 事件来获取出错的信息。
    发送 error 可能有下面两张引起的，或者其他程序问题，需要我们认真仔细。
    1、data:"{}", data 为空也一定要传"{}"；不然返回的是 xml 格式的。并提示 parsererror.
    2、parsererror 的异常和 Header 类型也有关系。及编码 header('Content-type: text/html; charset=utf8');
## 34.http 和 https 的区别是什么？
    http 和 https 使用的是完全不同的连接方式,用的端口也不一样,前者是 80,后者是 443。
    HTTPS 是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版。
    由于 https 要还密钥和确认加密算法的过程，所以更安全
## 35.什么是内存泄漏，哪些常见操作会造成内存泄漏
    内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。在 C++中，因为是手动管理
    内存，内存泄露是经常出现的事情。而现在流行的 C#和 Java 等语言采用了自动垃圾回收方法管理内存，正常
    使用的情况下几乎不会发生内存泄露。浏览器中也是采用自动垃圾回收方法管理内存，但由于浏览器垃圾回
    收方法有 bug，会产生内存泄露。
    1 全局变量引起的内存泄漏
    2 闭包引起的内存泄漏
    3dom 清空或删除时，事件未清除导致的内存泄漏
## 36.跨域的几种解决方式
    ① 通过 jsonp 跨域
    ② 通过修改 document.domain 来跨子域
    ③ 使用 window.name 来进行跨域
    ④ 使用 HTML5 中新引进的 window.postMessage 方法来跨域传送数据
    ⑤ CORS
    核心思想：在服务器端通过检查请求头部的 origin，从而决定请求应该成功还是失败。具体的方法是在服务端
    设置 Response Header 响应头中的 Access-Control-Allow-Origin 为对应的域名，实现了 CORS（跨域资源共享），
    这里出于在安全性方面的考虑就是尽量不要用 *，但对于一些不重要的数据则随意。
## 37.同源策略
    1. 同源，就是指两个页面具有相同的协议，主机（域名），端口，浏览器会对不同源的脚本或者文本的访问
方式进行的限制
    2. 页面中的链接，重定向以及表单提交不会受到同源策略的限制，允许跨域资源嵌入
## 38.简述 AJAX 的交互模型，以及同步和异步的区别
    AJAX 主要用于实现从服务器获取数据并局部刷新页面。其交互模型为，AJAX 在浏览
    器端引入一个执行引擎，它一边接收 user 的请求，一边传送数据给服务器，并把服务器端
    返回的结果展现给 user。
    同步：脚本会停留并等待服务器发送回复然后继续。
    异步：脚本不停留并处理可能的回复。
## 39.javascript 的本地对象，内置对象和宿主对象
    本地对象为 array obj regexp 等可以 new 实例化
    内置对象为 gload Math 等不可以实例化的
    宿主为浏览器自带的 document,window 等
## 40.简述 readyonly 与 disabled 的区别
    ReadOnly 和 Disabled 的作用是使用户不能够更改表单域中的内容.
    但是二者还是有着一些区别的：
    1、Readonly 只针对 input(text/password)和 textarea 有效，而 disabled 对于所有的表单元素有效，包括
    select,radio,checkbox,button 等。
    2、在表单元素使用了 disabled 后，我们将表单以 POST 或者 GET 的方式提交的话，这个元素的值不会被传递
    出去，而 readonly 会将该值传递出去
# 23/5/18
## 21.简单介绍一下 symbol
    Symbol 是 ES6 的新增属性，代表用给定名称作为唯一标识，这种类型的值可以这样创
    建，let id=symbol(“id”)
    Symbl 确保唯一，即使采用相同的名称，也会产生不同的值，我们创建一个字段，仅为
    知道对应 symbol 的人能访问，使用 symbol 很有用，symbol 并不是 100%隐藏，有内置
    方法 Object.getOwnPropertySymbols(obj)可以获得所有的 symbol。
    也有一个方法 Reflect.ownKeys(obj)返回对象所有的键，包括 symbol。
    所以并不是真正隐藏。但大多数库内置方法和语法结构遵循通用约定他们是隐藏的。
## 22.事件委托以及冒泡原理。
    事件委托是利用冒泡阶段的运行机制来实现的，就是把一个元素响应事件的函数委托
    到另一个元素，一般是把一组元素的事件委托到他的父元素上，委托的优点是
    减少内存消耗，节约效率
    动态绑定事件
    事件冒泡，就是元素自身的事件被触发后，如果父元素有相同的事件，如 onclick 事
    件，那么元素本身的触发状态就会传递，也就是冒到父元素，父元素的相同事件也会
    一级一级根据嵌套关系向外触发，直到 document/window，冒泡过程结束。
## 23.let const var 的区别 ，什么是块级作用域，如何用 ES5 的方法实现块级作用域（立即执行函数），ES6 呢
    提起这三个最明显的区别是 var 声明的变量是全局或者整个函数块的，而 let,const
    声明的变量是块级的变量，var 声明的变量存在变量提升，let,const 不存在，let 声
    明的变量允许重新赋值，const 不允许
## 24.setTimeout(fn,100);100 毫秒是如何权衡的
    setTimeout()函数只是将事件插入了任务列表，必须等到当前代码执行完，主线程才
    会去执行它指定的回调函数，有可能要等很久，所以没有办法保证回调函数一定会在
    setTimeout 指定的时间内执行，100 毫秒是插入队列的时间+等待的时间
## 25.JS 的垃圾回收机制
    GC（garbage collection），GC 执行时，中断代码，停止其他操作，遍历所有对象，
    对于不可访问的对象进行回收，在 V8 引擎中使用两种优化方法，
    分代回收，2、增量 GC，目的是通过对象的使用频率，存在时长来区分新生代和老生代
    对象，多回收新生代区，少回收老生代区，减少每次遍历的时间，从而减少 GC 的耗时
    回收方法：
    引用计次，当对象被引用的次数为零时进行回收，但是循环引用时，两个对象都至少
    被引用了一次，因此导致内存泄漏，
    标记清除
## 26.了解事件代理吗，这样做有什么好处
    事件代理/事件委托：利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类
    型的事件，
    简而言之：事件代理就是说我们将事件添加到本来要添加的事件的父节点，将事件委
    托给父节点来触发处理函数，这通常会使用在大量的同级元素需要添加同一类事件的
    时候，比如一个动态的非常多的列表，需要为每个列表项都添加点击事件，这时就可
    以使用事件代理，通过判断 e.target.nodeName 来判断发生的具体元素，这样做的好
    处是减少事件绑定，同时动态的 DOM 结构仍然可以监听，事件代理发生在冒泡阶段   
## 27. 知道 private 和 public 吗
    public：public 表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直
    接进行调用
    private：private 表示私有，私有的意思就是除了 class 自己之外，任何人都不可以
    直接使用
## 28.promise 和 await/async 的关系
    都是异步编程的解决方案
## 29.JS 加载过程阻塞，解决方法。
    指定 script 标签的 async 属性。
    如果 async="async"，脚本相对于页面的其余部分异步地执行（当页面继续进行解析
    时，脚本将被执行）
    如果不使用 async 且 defer="defer"：脚本将在页面完成解析时执行
## 30.es6 的常用
    promise，await/async，let、const、块级作用域、箭头函数
# 23/5/17
## 11.说说前端中的事件流
    HTML 中与 javascript 交互是通过事件驱动来实现的，例如鼠标点击事件 onclick、页
    面的滚动事件 onscroll 等等，可以向文档或者文档中的元素添加事件侦听器来预订事
    件。想要知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概
    念。
    什么是事件流：事件流描述的是从页面中接收事件的顺序,DOM2 级事件流包括下面几个
    阶段。
    事件捕获阶段
    处于目标阶段
    事件冒泡阶段
    addEventListener： addEventListener 是 DOM2 级事件新增的指定事件处理程序的操
    作，这个方法接收 3 个参数：要处理的事件名、作为事件处理程序的函数和一个布尔
    值。最后这个布尔值参数如果是 true，表示在捕获阶段调用事件处理程序；如果是
    false，表示在冒泡阶段调用事件处理程序。
    IE 只支持事件冒泡。
## 12.JS 拖拽功能的实现
    首先是三个事件，分别是 mousedown，mousemove，mouseup
    当鼠标点击按下的时候，需要一个 tag 标识此时已经按下，可以执行 mousemove 里面
    的具体方法。
    clientX，clientY 标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用
    offsetX 和 offsetY 来表示元素的元素的初始坐标，移动的举例应该是：
    鼠标移动时候的坐标-鼠标按下去时候的坐标。
    也就是说定位信息为：
    鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的 offetLeft.
    还有一点也是原理性的东西，也就是拖拽的同时是绝对定位，我们改变的是绝对定位
    条件下的 left
    以及 top 等等值。
    补充：也可以通过 html5 的拖放（Drag 和 drop）来实现
## 13.Ajax 解决浏览器缓存问题
    在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader("If-Modified-
    Since","0")。
    在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader("Cache-Control","no-
    cache")。
    在 URL 后面加上一个随机数： "fresh=" + Math.random()。
    在 URL 后面加上时间搓："nowtime=" + new Date().getTime()。
    如果是使用 jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所
    有 ajax 都会执行这条语句就是不需要保存缓存记录。
## 14.eval 是做什么的
    它的功能是将对应的字符串解析成 JS 并执行，应该避免使用 JS，因为非常消耗性能
    （2 次，一次解析成 JS，一次执行）
## 15.如何理解前端模块化
    前端模块化就是复杂的文件编程一个一个独立的模块，比如 JS 文件等等，分成独立的
    模块有利于重用（复用性）和维护（版本迭代），这样会引来模块之间相互依赖的问
    题，所以有了 commonJS 规范，AMD，CMD 规范等等，以及用于 JS 打包（编译等处理）
    的工具 webpack
## 16.事件代理在捕获阶段的实际应用
    可以在父元素层面阻止事件向子元素传播，也可代替子元素执行某些操作。
## 17.跨域的原理
    跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏
    览器对 JavaScript 实施的安全限制，那么只要协议、域名、端口有任何一个不同，都
    被当作是不同的域。跨域原理，即是通过各种方式，避开浏览器的安全限制。
## 18.什么是按需加载
    当用户触发了动作时才加载对应的功能。触发的动作，是要看具体的业务场景而言，
    包括但不限于以下几个情况：鼠标点击、输入文字、拉动滚动条，鼠标移动、窗口大
    小更改等。加载的文件，可以是 JS、图片、CSS、HTML 等。
## 19.webpack 用来干什么的
    webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当
    webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其
    中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。
## 20.ant-design 优点和缺点
    优点：组件非常全面，样式效果也都比较不错。
    缺点：框架自定义程度低，默认 UI 风格修改困难。
# 23/5/16
## 1.闭包是什么，闭包的作用是什么，对页面有什么影响?
    答：一个函数作为另一个函数的返回值，返回的这个函数可以调用父函数内部的其他变量
    作用：防止全局污染，保存外部活动变量
    影响：如果过多使用闭包，容易导致内存泄露
## 2.原型链
    任何一个类（函数）都有原型对象，原型对象至少有两个属性（constructor,proto）。constructor指向函数本身，proto指向父类原型对象。
    函数上有一个prototype属性，指向原型对象，通过它可以访问原型对象
    函数的实列可以直接访问原型对象(因为实列上有proto指向构造函数的原型对象)
## 3.浏览器缓存机制
    缓存分为两种：强缓存和协商缓存，根据响应的 header 内容来决定。
    强缓存相关字段有 expires，cache-control 。如果 cache -control 与 expires 同时存
    在的话，cache-control 的优先级高于 expires。
    协商缓存相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match
## 4.transition 和   animation 的区别
    Animation 和 transition 大部分属性是相同的，他们都是随时间改变元素的属性值，
    他们的主要区别是 transition 需要触发一个事件才能改变属性，而 animation 不需要
    触发任何事件的情况下才会随时间改变属性值，并且 transition 为 2 帧，从
    from .... to，而 animation 可以一帧一帧的
## 5.get 和  post 请求在缓存方面的区别
    get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以
    使用缓存。
    post 不同，post 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使
    用缓存。因此 get 请求适合于请求缓存。
## 6.call() 、apply()、bind()区别
    ● call() 和 apply() 方法直接调用原函数，并传递参数列表（或类数组对象）作为参数，它们能够立即改变函数的执行上下文。
    ● bind() 方法会创建一个新函数并返回它，而不是像 call() 和 apply() 方法一样立即调用原函数。新函数将原来的函数与指定的 this 值和参数绑定在一起，在随后的调用中，它们无法再次更改。
    另外，call() 和 apply() 通常用于临时更改函数的执行上下文，而bind() 则经常用于永久地将函数绑定到特定的上下文中，例如在事件处理程序或回调函数中。
     最后，需要注意的是这三个方法所表示的行为，都属于 JavaScript 的高阶函数特性，能够让我们更灵活的使用 JavaScript 函数进行编程。
## 7.原型链的概念及其作用
    在 JavaScript 中，每个对象都有一个指向它的原型对象，这些对象被链接在一起形成了原型链。当访问一个对象的属性或方法时，JavaScript 会沿着原型链向上查找，直到找到匹配的属性或方法为止。这种查找方式使得对象的属性和方法可以被共享和继承。
## 8.Local Storage 特点
    Local Storage 存储的数据量是有限的，通常为 5MB 到 10MB 不等，如果超过了这个限制则会抛出异常。此外，Local Storage 存储的数据会一直存在于用户的浏览器中，即使关闭了浏览器或电脑，数据也不会被清除
## 9.具体有哪些请求头是跟缓存相关的
    缓存分为两种：强缓存和协商缓存，根据响应的 header 内容来决定。
    强缓存相关字段有 expires，cache-control。如果 cache-control 与 expires 同时存
    在的话，cache-control 的优先级高于 expires。
## 10.cookie 和 和  session 的区别
    1. cookie 数据存放在客户的浏览器上，session 数据放在服务器上。
    2. cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺
    骗
    考虑到安全应当使用 session。
    3. session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务
    器的性能
    考虑到减轻服务器性能方面，应当使用 COOKIE。
    4. 单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存
    20 个 cookie。